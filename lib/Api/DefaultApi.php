<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * 阿波罗客户端
 *
 * 阿波罗客户端
 *
 * OpenAPI spec version: v0.0.2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.33
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteField
     *
     * 删除配置接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     * @param  string $key 字段名 (required)
     * @param  string $operator 删除配置的操作者，域账号 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteField($app_id, $env, $cluster_name, $namespace_name, $key, $operator)
    {
        $this->deleteFieldWithHttpInfo($app_id, $env, $cluster_name, $namespace_name, $key, $operator);
    }

    /**
     * Operation deleteFieldWithHttpInfo
     *
     * 删除配置接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     * @param  string $key 字段名 (required)
     * @param  string $operator 删除配置的操作者，域账号 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFieldWithHttpInfo($app_id, $env, $cluster_name, $namespace_name, $key, $operator)
    {
        $returnType = '';
        $request = $this->deleteFieldRequest($app_id, $env, $cluster_name, $namespace_name, $key, $operator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFieldAsync
     *
     * 删除配置接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     * @param  string $key 字段名 (required)
     * @param  string $operator 删除配置的操作者，域账号 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldAsync($app_id, $env, $cluster_name, $namespace_name, $key, $operator)
    {
        return $this->deleteFieldAsyncWithHttpInfo($app_id, $env, $cluster_name, $namespace_name, $key, $operator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFieldAsyncWithHttpInfo
     *
     * 删除配置接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     * @param  string $key 字段名 (required)
     * @param  string $operator 删除配置的操作者，域账号 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldAsyncWithHttpInfo($app_id, $env, $cluster_name, $namespace_name, $key, $operator)
    {
        $returnType = '';
        $request = $this->deleteFieldRequest($app_id, $env, $cluster_name, $namespace_name, $key, $operator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteField'
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     * @param  string $key 字段名 (required)
     * @param  string $operator 删除配置的操作者，域账号 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFieldRequest($app_id, $env, $cluster_name, $namespace_name, $key, $operator)
    {
        // verify the required parameter 'app_id' is set
        if ($app_id === null || (is_array($app_id) && count($app_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_id when calling deleteField'
            );
        }
        // verify the required parameter 'env' is set
        if ($env === null || (is_array($env) && count($env) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env when calling deleteField'
            );
        }
        // verify the required parameter 'cluster_name' is set
        if ($cluster_name === null || (is_array($cluster_name) && count($cluster_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_name when calling deleteField'
            );
        }
        // verify the required parameter 'namespace_name' is set
        if ($namespace_name === null || (is_array($namespace_name) && count($namespace_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace_name when calling deleteField'
            );
        }
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling deleteField'
            );
        }
        // verify the required parameter 'operator' is set
        if ($operator === null || (is_array($operator) && count($operator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $operator when calling deleteField'
            );
        }

        $resourcePath = '/envs/{env}/apps/{appId}/clusters/{clusterName}/namespaces/{namespaceName}/items/{key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($operator !== null) {
            $queryParams['operator'] = ObjectSerializer::toQueryValue($operator, null);
        }

        // path params
        if ($app_id !== null) {
            $resourcePath = str_replace(
                '{' . 'appId' . '}',
                ObjectSerializer::toPathValue($app_id),
                $resourcePath
            );
        }
        // path params
        if ($env !== null) {
            $resourcePath = str_replace(
                '{' . 'env' . '}',
                ObjectSerializer::toPathValue($env),
                $resourcePath
            );
        }
        // path params
        if ($cluster_name !== null) {
            $resourcePath = str_replace(
                '{' . 'clusterName' . '}',
                ObjectSerializer::toPathValue($cluster_name),
                $resourcePath
            );
        }
        // path params
        if ($namespace_name !== null) {
            $resourcePath = str_replace(
                '{' . 'namespaceName' . '}',
                ObjectSerializer::toPathValue($namespace_name),
                $resourcePath
            );
        }
        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAppInfo
     *
     * 获取App信息
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AppInfo[]
     */
    public function getAppInfo()
    {
        list($response) = $this->getAppInfoWithHttpInfo();
        return $response;
    }

    /**
     * Operation getAppInfoWithHttpInfo
     *
     * 获取App信息
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AppInfo[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getAppInfoWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\AppInfo[]';
        $request = $this->getAppInfoRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AppInfo[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAppInfoAsync
     *
     * 获取App信息
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAppInfoAsync()
    {
        return $this->getAppInfoAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAppInfoAsyncWithHttpInfo
     *
     * 获取App信息
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAppInfoAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\AppInfo[]';
        $request = $this->getAppInfoRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAppInfo'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAppInfoRequest()
    {

        $resourcePath = '/apps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getClusters
     *
     * 获取集群接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ClusterInfo
     */
    public function getClusters($app_id, $env, $cluster_name)
    {
        list($response) = $this->getClustersWithHttpInfo($app_id, $env, $cluster_name);
        return $response;
    }

    /**
     * Operation getClustersWithHttpInfo
     *
     * 获取集群接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ClusterInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function getClustersWithHttpInfo($app_id, $env, $cluster_name)
    {
        $returnType = '\Swagger\Client\Model\ClusterInfo';
        $request = $this->getClustersRequest($app_id, $env, $cluster_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ClusterInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getClustersAsync
     *
     * 获取集群接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClustersAsync($app_id, $env, $cluster_name)
    {
        return $this->getClustersAsyncWithHttpInfo($app_id, $env, $cluster_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getClustersAsyncWithHttpInfo
     *
     * 获取集群接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClustersAsyncWithHttpInfo($app_id, $env, $cluster_name)
    {
        $returnType = '\Swagger\Client\Model\ClusterInfo';
        $request = $this->getClustersRequest($app_id, $env, $cluster_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getClusters'
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getClustersRequest($app_id, $env, $cluster_name)
    {
        // verify the required parameter 'app_id' is set
        if ($app_id === null || (is_array($app_id) && count($app_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_id when calling getClusters'
            );
        }
        // verify the required parameter 'env' is set
        if ($env === null || (is_array($env) && count($env) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env when calling getClusters'
            );
        }
        // verify the required parameter 'cluster_name' is set
        if ($cluster_name === null || (is_array($cluster_name) && count($cluster_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_name when calling getClusters'
            );
        }

        $resourcePath = '/envs/{env}/apps/{appId}/clusters/{clusterName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_id !== null) {
            $resourcePath = str_replace(
                '{' . 'appId' . '}',
                ObjectSerializer::toPathValue($app_id),
                $resourcePath
            );
        }
        // path params
        if ($env !== null) {
            $resourcePath = str_replace(
                '{' . 'env' . '}',
                ObjectSerializer::toPathValue($env),
                $resourcePath
            );
        }
        // path params
        if ($cluster_name !== null) {
            $resourcePath = str_replace(
                '{' . 'clusterName' . '}',
                ObjectSerializer::toPathValue($cluster_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEnvClustersById
     *
     * 获取App的环境，集群信息
     *
     * @param  string $app_id 应用id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\EnvCluster[]
     */
    public function getEnvClustersById($app_id)
    {
        list($response) = $this->getEnvClustersByIdWithHttpInfo($app_id);
        return $response;
    }

    /**
     * Operation getEnvClustersByIdWithHttpInfo
     *
     * 获取App的环境，集群信息
     *
     * @param  string $app_id 应用id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\EnvCluster[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getEnvClustersByIdWithHttpInfo($app_id)
    {
        $returnType = '\Swagger\Client\Model\EnvCluster[]';
        $request = $this->getEnvClustersByIdRequest($app_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\EnvCluster[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEnvClustersByIdAsync
     *
     * 获取App的环境，集群信息
     *
     * @param  string $app_id 应用id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEnvClustersByIdAsync($app_id)
    {
        return $this->getEnvClustersByIdAsyncWithHttpInfo($app_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEnvClustersByIdAsyncWithHttpInfo
     *
     * 获取App的环境，集群信息
     *
     * @param  string $app_id 应用id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEnvClustersByIdAsyncWithHttpInfo($app_id)
    {
        $returnType = '\Swagger\Client\Model\EnvCluster[]';
        $request = $this->getEnvClustersByIdRequest($app_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEnvClustersById'
     *
     * @param  string $app_id 应用id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEnvClustersByIdRequest($app_id)
    {
        // verify the required parameter 'app_id' is set
        if ($app_id === null || (is_array($app_id) && count($app_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_id when calling getEnvClustersById'
            );
        }

        $resourcePath = '/apps/{appId}/envclusters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_id !== null) {
            $resourcePath = str_replace(
                '{' . 'appId' . '}',
                ObjectSerializer::toPathValue($app_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getField
     *
     * 读取配置接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     * @param  string $key 字段名 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Field
     */
    public function getField($app_id, $env, $cluster_name, $namespace_name, $key)
    {
        list($response) = $this->getFieldWithHttpInfo($app_id, $env, $cluster_name, $namespace_name, $key);
        return $response;
    }

    /**
     * Operation getFieldWithHttpInfo
     *
     * 读取配置接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     * @param  string $key 字段名 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Field, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFieldWithHttpInfo($app_id, $env, $cluster_name, $namespace_name, $key)
    {
        $returnType = '\Swagger\Client\Model\Field';
        $request = $this->getFieldRequest($app_id, $env, $cluster_name, $namespace_name, $key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Field',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFieldAsync
     *
     * 读取配置接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     * @param  string $key 字段名 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldAsync($app_id, $env, $cluster_name, $namespace_name, $key)
    {
        return $this->getFieldAsyncWithHttpInfo($app_id, $env, $cluster_name, $namespace_name, $key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFieldAsyncWithHttpInfo
     *
     * 读取配置接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     * @param  string $key 字段名 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldAsyncWithHttpInfo($app_id, $env, $cluster_name, $namespace_name, $key)
    {
        $returnType = '\Swagger\Client\Model\Field';
        $request = $this->getFieldRequest($app_id, $env, $cluster_name, $namespace_name, $key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getField'
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     * @param  string $key 字段名 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFieldRequest($app_id, $env, $cluster_name, $namespace_name, $key)
    {
        // verify the required parameter 'app_id' is set
        if ($app_id === null || (is_array($app_id) && count($app_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_id when calling getField'
            );
        }
        // verify the required parameter 'env' is set
        if ($env === null || (is_array($env) && count($env) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env when calling getField'
            );
        }
        // verify the required parameter 'cluster_name' is set
        if ($cluster_name === null || (is_array($cluster_name) && count($cluster_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_name when calling getField'
            );
        }
        // verify the required parameter 'namespace_name' is set
        if ($namespace_name === null || (is_array($namespace_name) && count($namespace_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace_name when calling getField'
            );
        }
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getField'
            );
        }

        $resourcePath = '/envs/{env}/apps/{appId}/clusters/{clusterName}/namespaces/{namespaceName}/items/{key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_id !== null) {
            $resourcePath = str_replace(
                '{' . 'appId' . '}',
                ObjectSerializer::toPathValue($app_id),
                $resourcePath
            );
        }
        // path params
        if ($env !== null) {
            $resourcePath = str_replace(
                '{' . 'env' . '}',
                ObjectSerializer::toPathValue($env),
                $resourcePath
            );
        }
        // path params
        if ($cluster_name !== null) {
            $resourcePath = str_replace(
                '{' . 'clusterName' . '}',
                ObjectSerializer::toPathValue($cluster_name),
                $resourcePath
            );
        }
        // path params
        if ($namespace_name !== null) {
            $resourcePath = str_replace(
                '{' . 'namespaceName' . '}',
                ObjectSerializer::toPathValue($namespace_name),
                $resourcePath
            );
        }
        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLock
     *
     * 获取某个Namespace当前编辑人接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Lock
     */
    public function getLock($app_id, $env, $cluster_name, $namespace_name)
    {
        list($response) = $this->getLockWithHttpInfo($app_id, $env, $cluster_name, $namespace_name);
        return $response;
    }

    /**
     * Operation getLockWithHttpInfo
     *
     * 获取某个Namespace当前编辑人接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Lock, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLockWithHttpInfo($app_id, $env, $cluster_name, $namespace_name)
    {
        $returnType = '\Swagger\Client\Model\Lock';
        $request = $this->getLockRequest($app_id, $env, $cluster_name, $namespace_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Lock',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLockAsync
     *
     * 获取某个Namespace当前编辑人接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLockAsync($app_id, $env, $cluster_name, $namespace_name)
    {
        return $this->getLockAsyncWithHttpInfo($app_id, $env, $cluster_name, $namespace_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLockAsyncWithHttpInfo
     *
     * 获取某个Namespace当前编辑人接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLockAsyncWithHttpInfo($app_id, $env, $cluster_name, $namespace_name)
    {
        $returnType = '\Swagger\Client\Model\Lock';
        $request = $this->getLockRequest($app_id, $env, $cluster_name, $namespace_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLock'
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLockRequest($app_id, $env, $cluster_name, $namespace_name)
    {
        // verify the required parameter 'app_id' is set
        if ($app_id === null || (is_array($app_id) && count($app_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_id when calling getLock'
            );
        }
        // verify the required parameter 'env' is set
        if ($env === null || (is_array($env) && count($env) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env when calling getLock'
            );
        }
        // verify the required parameter 'cluster_name' is set
        if ($cluster_name === null || (is_array($cluster_name) && count($cluster_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_name when calling getLock'
            );
        }
        // verify the required parameter 'namespace_name' is set
        if ($namespace_name === null || (is_array($namespace_name) && count($namespace_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace_name when calling getLock'
            );
        }

        $resourcePath = '/envs/{env}/apps/{appId}/clusters/{clusterName}/namespaces/{namespaceName}/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_id !== null) {
            $resourcePath = str_replace(
                '{' . 'appId' . '}',
                ObjectSerializer::toPathValue($app_id),
                $resourcePath
            );
        }
        // path params
        if ($env !== null) {
            $resourcePath = str_replace(
                '{' . 'env' . '}',
                ObjectSerializer::toPathValue($env),
                $resourcePath
            );
        }
        // path params
        if ($cluster_name !== null) {
            $resourcePath = str_replace(
                '{' . 'clusterName' . '}',
                ObjectSerializer::toPathValue($cluster_name),
                $resourcePath
            );
        }
        // path params
        if ($namespace_name !== null) {
            $resourcePath = str_replace(
                '{' . 'namespaceName' . '}',
                ObjectSerializer::toPathValue($namespace_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNamespace
     *
     * 获取某个Namespace信息接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelNamespace
     */
    public function getNamespace($app_id, $env, $cluster_name, $namespace_name)
    {
        list($response) = $this->getNamespaceWithHttpInfo($app_id, $env, $cluster_name, $namespace_name);
        return $response;
    }

    /**
     * Operation getNamespaceWithHttpInfo
     *
     * 获取某个Namespace信息接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelNamespace, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNamespaceWithHttpInfo($app_id, $env, $cluster_name, $namespace_name)
    {
        $returnType = '\Swagger\Client\Model\ModelNamespace';
        $request = $this->getNamespaceRequest($app_id, $env, $cluster_name, $namespace_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ModelNamespace',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNamespaceAsync
     *
     * 获取某个Namespace信息接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNamespaceAsync($app_id, $env, $cluster_name, $namespace_name)
    {
        return $this->getNamespaceAsyncWithHttpInfo($app_id, $env, $cluster_name, $namespace_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNamespaceAsyncWithHttpInfo
     *
     * 获取某个Namespace信息接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNamespaceAsyncWithHttpInfo($app_id, $env, $cluster_name, $namespace_name)
    {
        $returnType = '\Swagger\Client\Model\ModelNamespace';
        $request = $this->getNamespaceRequest($app_id, $env, $cluster_name, $namespace_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNamespace'
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNamespaceRequest($app_id, $env, $cluster_name, $namespace_name)
    {
        // verify the required parameter 'app_id' is set
        if ($app_id === null || (is_array($app_id) && count($app_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_id when calling getNamespace'
            );
        }
        // verify the required parameter 'env' is set
        if ($env === null || (is_array($env) && count($env) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env when calling getNamespace'
            );
        }
        // verify the required parameter 'cluster_name' is set
        if ($cluster_name === null || (is_array($cluster_name) && count($cluster_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_name when calling getNamespace'
            );
        }
        // verify the required parameter 'namespace_name' is set
        if ($namespace_name === null || (is_array($namespace_name) && count($namespace_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace_name when calling getNamespace'
            );
        }

        $resourcePath = '/envs/{env}/apps/{appId}/clusters/{clusterName}/namespaces/{namespaceName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_id !== null) {
            $resourcePath = str_replace(
                '{' . 'appId' . '}',
                ObjectSerializer::toPathValue($app_id),
                $resourcePath
            );
        }
        // path params
        if ($env !== null) {
            $resourcePath = str_replace(
                '{' . 'env' . '}',
                ObjectSerializer::toPathValue($env),
                $resourcePath
            );
        }
        // path params
        if ($cluster_name !== null) {
            $resourcePath = str_replace(
                '{' . 'clusterName' . '}',
                ObjectSerializer::toPathValue($cluster_name),
                $resourcePath
            );
        }
        // path params
        if ($namespace_name !== null) {
            $resourcePath = str_replace(
                '{' . 'namespaceName' . '}',
                ObjectSerializer::toPathValue($namespace_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNamespaces
     *
     * 获取集群下所有Namespace信息接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelNamespace[]
     */
    public function getNamespaces($app_id, $env, $cluster_name)
    {
        list($response) = $this->getNamespacesWithHttpInfo($app_id, $env, $cluster_name);
        return $response;
    }

    /**
     * Operation getNamespacesWithHttpInfo
     *
     * 获取集群下所有Namespace信息接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelNamespace[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNamespacesWithHttpInfo($app_id, $env, $cluster_name)
    {
        $returnType = '\Swagger\Client\Model\ModelNamespace[]';
        $request = $this->getNamespacesRequest($app_id, $env, $cluster_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ModelNamespace[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNamespacesAsync
     *
     * 获取集群下所有Namespace信息接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNamespacesAsync($app_id, $env, $cluster_name)
    {
        return $this->getNamespacesAsyncWithHttpInfo($app_id, $env, $cluster_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNamespacesAsyncWithHttpInfo
     *
     * 获取集群下所有Namespace信息接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNamespacesAsyncWithHttpInfo($app_id, $env, $cluster_name)
    {
        $returnType = '\Swagger\Client\Model\ModelNamespace[]';
        $request = $this->getNamespacesRequest($app_id, $env, $cluster_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNamespaces'
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNamespacesRequest($app_id, $env, $cluster_name)
    {
        // verify the required parameter 'app_id' is set
        if ($app_id === null || (is_array($app_id) && count($app_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_id when calling getNamespaces'
            );
        }
        // verify the required parameter 'env' is set
        if ($env === null || (is_array($env) && count($env) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env when calling getNamespaces'
            );
        }
        // verify the required parameter 'cluster_name' is set
        if ($cluster_name === null || (is_array($cluster_name) && count($cluster_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_name when calling getNamespaces'
            );
        }

        $resourcePath = '/envs/{env}/apps/{appId}/clusters/{clusterName}/namespaces';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_id !== null) {
            $resourcePath = str_replace(
                '{' . 'appId' . '}',
                ObjectSerializer::toPathValue($app_id),
                $resourcePath
            );
        }
        // path params
        if ($env !== null) {
            $resourcePath = str_replace(
                '{' . 'env' . '}',
                ObjectSerializer::toPathValue($env),
                $resourcePath
            );
        }
        // path params
        if ($cluster_name !== null) {
            $resourcePath = str_replace(
                '{' . 'clusterName' . '}',
                ObjectSerializer::toPathValue($cluster_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getReleases
     *
     * 获取生效配置接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Releases
     */
    public function getReleases($app_id, $env, $cluster_name, $namespace_name)
    {
        list($response) = $this->getReleasesWithHttpInfo($app_id, $env, $cluster_name, $namespace_name);
        return $response;
    }

    /**
     * Operation getReleasesWithHttpInfo
     *
     * 获取生效配置接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Releases, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReleasesWithHttpInfo($app_id, $env, $cluster_name, $namespace_name)
    {
        $returnType = '\Swagger\Client\Model\Releases';
        $request = $this->getReleasesRequest($app_id, $env, $cluster_name, $namespace_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Releases',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReleasesAsync
     *
     * 获取生效配置接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReleasesAsync($app_id, $env, $cluster_name, $namespace_name)
    {
        return $this->getReleasesAsyncWithHttpInfo($app_id, $env, $cluster_name, $namespace_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReleasesAsyncWithHttpInfo
     *
     * 获取生效配置接口
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReleasesAsyncWithHttpInfo($app_id, $env, $cluster_name, $namespace_name)
    {
        $returnType = '\Swagger\Client\Model\Releases';
        $request = $this->getReleasesRequest($app_id, $env, $cluster_name, $namespace_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReleases'
     *
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getReleasesRequest($app_id, $env, $cluster_name, $namespace_name)
    {
        // verify the required parameter 'app_id' is set
        if ($app_id === null || (is_array($app_id) && count($app_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_id when calling getReleases'
            );
        }
        // verify the required parameter 'env' is set
        if ($env === null || (is_array($env) && count($env) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env when calling getReleases'
            );
        }
        // verify the required parameter 'cluster_name' is set
        if ($cluster_name === null || (is_array($cluster_name) && count($cluster_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_name when calling getReleases'
            );
        }
        // verify the required parameter 'namespace_name' is set
        if ($namespace_name === null || (is_array($namespace_name) && count($namespace_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace_name when calling getReleases'
            );
        }

        $resourcePath = '/envs/{env}/apps/{appId}/clusters/{clusterName}/namespaces/{namespaceName}/releases/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_id !== null) {
            $resourcePath = str_replace(
                '{' . 'appId' . '}',
                ObjectSerializer::toPathValue($app_id),
                $resourcePath
            );
        }
        // path params
        if ($env !== null) {
            $resourcePath = str_replace(
                '{' . 'env' . '}',
                ObjectSerializer::toPathValue($env),
                $resourcePath
            );
        }
        // path params
        if ($cluster_name !== null) {
            $resourcePath = str_replace(
                '{' . 'clusterName' . '}',
                ObjectSerializer::toPathValue($cluster_name),
                $resourcePath
            );
        }
        // path params
        if ($namespace_name !== null) {
            $resourcePath = str_replace(
                '{' . 'namespaceName' . '}',
                ObjectSerializer::toPathValue($namespace_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postClusters
     *
     * 创建集群接口
     *
     * @param  \Swagger\Client\Model\ClusterInfoBase $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ClusterInfo
     */
    public function postClusters($body, $app_id, $env)
    {
        list($response) = $this->postClustersWithHttpInfo($body, $app_id, $env);
        return $response;
    }

    /**
     * Operation postClustersWithHttpInfo
     *
     * 创建集群接口
     *
     * @param  \Swagger\Client\Model\ClusterInfoBase $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ClusterInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function postClustersWithHttpInfo($body, $app_id, $env)
    {
        $returnType = '\Swagger\Client\Model\ClusterInfo';
        $request = $this->postClustersRequest($body, $app_id, $env);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ClusterInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postClustersAsync
     *
     * 创建集群接口
     *
     * @param  \Swagger\Client\Model\ClusterInfoBase $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postClustersAsync($body, $app_id, $env)
    {
        return $this->postClustersAsyncWithHttpInfo($body, $app_id, $env)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postClustersAsyncWithHttpInfo
     *
     * 创建集群接口
     *
     * @param  \Swagger\Client\Model\ClusterInfoBase $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postClustersAsyncWithHttpInfo($body, $app_id, $env)
    {
        $returnType = '\Swagger\Client\Model\ClusterInfo';
        $request = $this->postClustersRequest($body, $app_id, $env);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postClusters'
     *
     * @param  \Swagger\Client\Model\ClusterInfoBase $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postClustersRequest($body, $app_id, $env)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postClusters'
            );
        }
        // verify the required parameter 'app_id' is set
        if ($app_id === null || (is_array($app_id) && count($app_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_id when calling postClusters'
            );
        }
        // verify the required parameter 'env' is set
        if ($env === null || (is_array($env) && count($env) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env when calling postClusters'
            );
        }

        $resourcePath = '/envs/{env}/apps/{appId}/clusters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_id !== null) {
            $resourcePath = str_replace(
                '{' . 'appId' . '}',
                ObjectSerializer::toPathValue($app_id),
                $resourcePath
            );
        }
        // path params
        if ($env !== null) {
            $resourcePath = str_replace(
                '{' . 'env' . '}',
                ObjectSerializer::toPathValue($env),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postField
     *
     * 新增配置接口
     *
     * @param  \Swagger\Client\Model\FieldBase $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Field
     */
    public function postField($body, $app_id, $env, $cluster_name, $namespace_name)
    {
        list($response) = $this->postFieldWithHttpInfo($body, $app_id, $env, $cluster_name, $namespace_name);
        return $response;
    }

    /**
     * Operation postFieldWithHttpInfo
     *
     * 新增配置接口
     *
     * @param  \Swagger\Client\Model\FieldBase $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Field, HTTP status code, HTTP response headers (array of strings)
     */
    public function postFieldWithHttpInfo($body, $app_id, $env, $cluster_name, $namespace_name)
    {
        $returnType = '\Swagger\Client\Model\Field';
        $request = $this->postFieldRequest($body, $app_id, $env, $cluster_name, $namespace_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Field',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postFieldAsync
     *
     * 新增配置接口
     *
     * @param  \Swagger\Client\Model\FieldBase $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFieldAsync($body, $app_id, $env, $cluster_name, $namespace_name)
    {
        return $this->postFieldAsyncWithHttpInfo($body, $app_id, $env, $cluster_name, $namespace_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postFieldAsyncWithHttpInfo
     *
     * 新增配置接口
     *
     * @param  \Swagger\Client\Model\FieldBase $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFieldAsyncWithHttpInfo($body, $app_id, $env, $cluster_name, $namespace_name)
    {
        $returnType = '\Swagger\Client\Model\Field';
        $request = $this->postFieldRequest($body, $app_id, $env, $cluster_name, $namespace_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postField'
     *
     * @param  \Swagger\Client\Model\FieldBase $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postFieldRequest($body, $app_id, $env, $cluster_name, $namespace_name)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postField'
            );
        }
        // verify the required parameter 'app_id' is set
        if ($app_id === null || (is_array($app_id) && count($app_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_id when calling postField'
            );
        }
        // verify the required parameter 'env' is set
        if ($env === null || (is_array($env) && count($env) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env when calling postField'
            );
        }
        // verify the required parameter 'cluster_name' is set
        if ($cluster_name === null || (is_array($cluster_name) && count($cluster_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_name when calling postField'
            );
        }
        // verify the required parameter 'namespace_name' is set
        if ($namespace_name === null || (is_array($namespace_name) && count($namespace_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace_name when calling postField'
            );
        }

        $resourcePath = '/envs/{env}/apps/{appId}/clusters/{clusterName}/namespaces/{namespaceName}/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_id !== null) {
            $resourcePath = str_replace(
                '{' . 'appId' . '}',
                ObjectSerializer::toPathValue($app_id),
                $resourcePath
            );
        }
        // path params
        if ($env !== null) {
            $resourcePath = str_replace(
                '{' . 'env' . '}',
                ObjectSerializer::toPathValue($env),
                $resourcePath
            );
        }
        // path params
        if ($cluster_name !== null) {
            $resourcePath = str_replace(
                '{' . 'clusterName' . '}',
                ObjectSerializer::toPathValue($cluster_name),
                $resourcePath
            );
        }
        // path params
        if ($namespace_name !== null) {
            $resourcePath = str_replace(
                '{' . 'namespaceName' . '}',
                ObjectSerializer::toPathValue($namespace_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postNamespace
     *
     * 创建Namespace
     *
     * @param  \Swagger\Client\Model\NamespaceBase $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\NamespaceInfo
     */
    public function postNamespace($body, $app_id)
    {
        list($response) = $this->postNamespaceWithHttpInfo($body, $app_id);
        return $response;
    }

    /**
     * Operation postNamespaceWithHttpInfo
     *
     * 创建Namespace
     *
     * @param  \Swagger\Client\Model\NamespaceBase $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\NamespaceInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function postNamespaceWithHttpInfo($body, $app_id)
    {
        $returnType = '\Swagger\Client\Model\NamespaceInfo';
        $request = $this->postNamespaceRequest($body, $app_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\NamespaceInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postNamespaceAsync
     *
     * 创建Namespace
     *
     * @param  \Swagger\Client\Model\NamespaceBase $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postNamespaceAsync($body, $app_id)
    {
        return $this->postNamespaceAsyncWithHttpInfo($body, $app_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postNamespaceAsyncWithHttpInfo
     *
     * 创建Namespace
     *
     * @param  \Swagger\Client\Model\NamespaceBase $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postNamespaceAsyncWithHttpInfo($body, $app_id)
    {
        $returnType = '\Swagger\Client\Model\NamespaceInfo';
        $request = $this->postNamespaceRequest($body, $app_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postNamespace'
     *
     * @param  \Swagger\Client\Model\NamespaceBase $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postNamespaceRequest($body, $app_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postNamespace'
            );
        }
        // verify the required parameter 'app_id' is set
        if ($app_id === null || (is_array($app_id) && count($app_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_id when calling postNamespace'
            );
        }

        $resourcePath = '/apps/{appId}/appnamespaces';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_id !== null) {
            $resourcePath = str_replace(
                '{' . 'appId' . '}',
                ObjectSerializer::toPathValue($app_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postReleases
     *
     * 发布配置接口
     *
     * @param  \Swagger\Client\Model\ReleasesPost $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Releases
     */
    public function postReleases($body, $app_id, $env, $cluster_name, $namespace_name)
    {
        list($response) = $this->postReleasesWithHttpInfo($body, $app_id, $env, $cluster_name, $namespace_name);
        return $response;
    }

    /**
     * Operation postReleasesWithHttpInfo
     *
     * 发布配置接口
     *
     * @param  \Swagger\Client\Model\ReleasesPost $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Releases, HTTP status code, HTTP response headers (array of strings)
     */
    public function postReleasesWithHttpInfo($body, $app_id, $env, $cluster_name, $namespace_name)
    {
        $returnType = '\Swagger\Client\Model\Releases';
        $request = $this->postReleasesRequest($body, $app_id, $env, $cluster_name, $namespace_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Releases',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postReleasesAsync
     *
     * 发布配置接口
     *
     * @param  \Swagger\Client\Model\ReleasesPost $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postReleasesAsync($body, $app_id, $env, $cluster_name, $namespace_name)
    {
        return $this->postReleasesAsyncWithHttpInfo($body, $app_id, $env, $cluster_name, $namespace_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postReleasesAsyncWithHttpInfo
     *
     * 发布配置接口
     *
     * @param  \Swagger\Client\Model\ReleasesPost $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postReleasesAsyncWithHttpInfo($body, $app_id, $env, $cluster_name, $namespace_name)
    {
        $returnType = '\Swagger\Client\Model\Releases';
        $request = $this->postReleasesRequest($body, $app_id, $env, $cluster_name, $namespace_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postReleases'
     *
     * @param  \Swagger\Client\Model\ReleasesPost $body post携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postReleasesRequest($body, $app_id, $env, $cluster_name, $namespace_name)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postReleases'
            );
        }
        // verify the required parameter 'app_id' is set
        if ($app_id === null || (is_array($app_id) && count($app_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_id when calling postReleases'
            );
        }
        // verify the required parameter 'env' is set
        if ($env === null || (is_array($env) && count($env) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env when calling postReleases'
            );
        }
        // verify the required parameter 'cluster_name' is set
        if ($cluster_name === null || (is_array($cluster_name) && count($cluster_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_name when calling postReleases'
            );
        }
        // verify the required parameter 'namespace_name' is set
        if ($namespace_name === null || (is_array($namespace_name) && count($namespace_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace_name when calling postReleases'
            );
        }

        $resourcePath = '/envs/{env}/apps/{appId}/clusters/{clusterName}/namespaces/{namespaceName}/releases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_id !== null) {
            $resourcePath = str_replace(
                '{' . 'appId' . '}',
                ObjectSerializer::toPathValue($app_id),
                $resourcePath
            );
        }
        // path params
        if ($env !== null) {
            $resourcePath = str_replace(
                '{' . 'env' . '}',
                ObjectSerializer::toPathValue($env),
                $resourcePath
            );
        }
        // path params
        if ($cluster_name !== null) {
            $resourcePath = str_replace(
                '{' . 'clusterName' . '}',
                ObjectSerializer::toPathValue($cluster_name),
                $resourcePath
            );
        }
        // path params
        if ($namespace_name !== null) {
            $resourcePath = str_replace(
                '{' . 'namespaceName' . '}',
                ObjectSerializer::toPathValue($namespace_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putField
     *
     * 修改配置接口
     *
     * @param  \Swagger\Client\Model\FieldPut $body 携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     * @param  string $key 字段名 (required)
     * @param  bool $create_if_not_exists 当配置不存在时是否自动创建 (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putField($body, $app_id, $env, $cluster_name, $namespace_name, $key, $create_if_not_exists = null)
    {
        $this->putFieldWithHttpInfo($body, $app_id, $env, $cluster_name, $namespace_name, $key, $create_if_not_exists);
    }

    /**
     * Operation putFieldWithHttpInfo
     *
     * 修改配置接口
     *
     * @param  \Swagger\Client\Model\FieldPut $body 携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     * @param  string $key 字段名 (required)
     * @param  bool $create_if_not_exists 当配置不存在时是否自动创建 (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putFieldWithHttpInfo($body, $app_id, $env, $cluster_name, $namespace_name, $key, $create_if_not_exists = null)
    {
        $returnType = '';
        $request = $this->putFieldRequest($body, $app_id, $env, $cluster_name, $namespace_name, $key, $create_if_not_exists);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putFieldAsync
     *
     * 修改配置接口
     *
     * @param  \Swagger\Client\Model\FieldPut $body 携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     * @param  string $key 字段名 (required)
     * @param  bool $create_if_not_exists 当配置不存在时是否自动创建 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFieldAsync($body, $app_id, $env, $cluster_name, $namespace_name, $key, $create_if_not_exists = null)
    {
        return $this->putFieldAsyncWithHttpInfo($body, $app_id, $env, $cluster_name, $namespace_name, $key, $create_if_not_exists)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putFieldAsyncWithHttpInfo
     *
     * 修改配置接口
     *
     * @param  \Swagger\Client\Model\FieldPut $body 携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     * @param  string $key 字段名 (required)
     * @param  bool $create_if_not_exists 当配置不存在时是否自动创建 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFieldAsyncWithHttpInfo($body, $app_id, $env, $cluster_name, $namespace_name, $key, $create_if_not_exists = null)
    {
        $returnType = '';
        $request = $this->putFieldRequest($body, $app_id, $env, $cluster_name, $namespace_name, $key, $create_if_not_exists);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putField'
     *
     * @param  \Swagger\Client\Model\FieldPut $body 携带参数 (required)
     * @param  string $app_id 应用id (required)
     * @param  string $env 环境 (required)
     * @param  string $cluster_name 集群名称 (required)
     * @param  string $namespace_name 命名空间名称 (required)
     * @param  string $key 字段名 (required)
     * @param  bool $create_if_not_exists 当配置不存在时是否自动创建 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putFieldRequest($body, $app_id, $env, $cluster_name, $namespace_name, $key, $create_if_not_exists = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putField'
            );
        }
        // verify the required parameter 'app_id' is set
        if ($app_id === null || (is_array($app_id) && count($app_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_id when calling putField'
            );
        }
        // verify the required parameter 'env' is set
        if ($env === null || (is_array($env) && count($env) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env when calling putField'
            );
        }
        // verify the required parameter 'cluster_name' is set
        if ($cluster_name === null || (is_array($cluster_name) && count($cluster_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_name when calling putField'
            );
        }
        // verify the required parameter 'namespace_name' is set
        if ($namespace_name === null || (is_array($namespace_name) && count($namespace_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace_name when calling putField'
            );
        }
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling putField'
            );
        }

        $resourcePath = '/envs/{env}/apps/{appId}/clusters/{clusterName}/namespaces/{namespaceName}/items/{key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($create_if_not_exists !== null) {
            $queryParams['createIfNotExists'] = ObjectSerializer::toQueryValue($create_if_not_exists, null);
        }

        // path params
        if ($app_id !== null) {
            $resourcePath = str_replace(
                '{' . 'appId' . '}',
                ObjectSerializer::toPathValue($app_id),
                $resourcePath
            );
        }
        // path params
        if ($env !== null) {
            $resourcePath = str_replace(
                '{' . 'env' . '}',
                ObjectSerializer::toPathValue($env),
                $resourcePath
            );
        }
        // path params
        if ($cluster_name !== null) {
            $resourcePath = str_replace(
                '{' . 'clusterName' . '}',
                ObjectSerializer::toPathValue($cluster_name),
                $resourcePath
            );
        }
        // path params
        if ($namespace_name !== null) {
            $resourcePath = str_replace(
                '{' . 'namespaceName' . '}',
                ObjectSerializer::toPathValue($namespace_name),
                $resourcePath
            );
        }
        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rollback
     *
     * 回滚已发布配置接口
     *
     * @param  string $operator 删除配置的操作者，域账号 (required)
     * @param  string $release_id 发布记录id (required)
     * @param  string $env 环境 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Releases
     */
    public function rollback($operator, $release_id, $env)
    {
        list($response) = $this->rollbackWithHttpInfo($operator, $release_id, $env);
        return $response;
    }

    /**
     * Operation rollbackWithHttpInfo
     *
     * 回滚已发布配置接口
     *
     * @param  string $operator 删除配置的操作者，域账号 (required)
     * @param  string $release_id 发布记录id (required)
     * @param  string $env 环境 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Releases, HTTP status code, HTTP response headers (array of strings)
     */
    public function rollbackWithHttpInfo($operator, $release_id, $env)
    {
        $returnType = '\Swagger\Client\Model\Releases';
        $request = $this->rollbackRequest($operator, $release_id, $env);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Releases',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rollbackAsync
     *
     * 回滚已发布配置接口
     *
     * @param  string $operator 删除配置的操作者，域账号 (required)
     * @param  string $release_id 发布记录id (required)
     * @param  string $env 环境 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rollbackAsync($operator, $release_id, $env)
    {
        return $this->rollbackAsyncWithHttpInfo($operator, $release_id, $env)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rollbackAsyncWithHttpInfo
     *
     * 回滚已发布配置接口
     *
     * @param  string $operator 删除配置的操作者，域账号 (required)
     * @param  string $release_id 发布记录id (required)
     * @param  string $env 环境 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rollbackAsyncWithHttpInfo($operator, $release_id, $env)
    {
        $returnType = '\Swagger\Client\Model\Releases';
        $request = $this->rollbackRequest($operator, $release_id, $env);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rollback'
     *
     * @param  string $operator 删除配置的操作者，域账号 (required)
     * @param  string $release_id 发布记录id (required)
     * @param  string $env 环境 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rollbackRequest($operator, $release_id, $env)
    {
        // verify the required parameter 'operator' is set
        if ($operator === null || (is_array($operator) && count($operator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $operator when calling rollback'
            );
        }
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling rollback'
            );
        }
        // verify the required parameter 'env' is set
        if ($env === null || (is_array($env) && count($env) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $env when calling rollback'
            );
        }

        $resourcePath = '/envs/{env}/releases/{releaseId}/rollback';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($operator !== null) {
            $queryParams['operator'] = ObjectSerializer::toQueryValue($operator, null);
        }

        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'releaseId' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($env !== null) {
            $resourcePath = str_replace(
                '{' . 'env' . '}',
                ObjectSerializer::toPathValue($env),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
